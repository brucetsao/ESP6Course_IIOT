/*
 CRC16 是一種檢查和校驗（Cyclic Redundancy Check）的方法，
 用於檢查一段資料是否有被修改或傳輸中出現錯誤。
 CRC16 會產生一個 16 位元的校驗碼（checksum），
 並與原始資料一起傳送或儲存。
 接收端在接收到資料後，
 重新計算 CRC16，
 若與接收到的 CRC16 相符，
 就表示接收到的資料是正確的。
 若不符，則需要重新傳輸或重新計算。

CRC16 的計算方式是將資料當做二進位位元串，再用除法演算法進行計算。計算過程中需要一個稱為「生成多項式」的參數，其值會影響 CRC16 的運算結果。常見的 CRC16 生成多項式有 CCITT、XMODEM、MODBUS 等。CRC16 被廣泛應用於通訊、存儲系統、電子設備等領域，可以提高資料的可靠性。
 需要重新傳輸或採取其他措施來修正錯誤。
 在程式碼中，
 CRC16被用來檢查讀取到的數據是否正確，
 如果校驗值不正確，
 則需要重新發送請求並重新讀取數據。
 當進行資料通訊時，
傳送方會將資料加上 CRC（Cyclic Redundancy Check）檢查碼，
接收方在接收到資料後會檢查 CRC 檢查碼，
以確保資料在傳輸過程中是否有發生錯誤。

CRC16 是一種檢查碼演算法，
它使用 16 位元的二進位位元組（byte）作為輸入，
並輸出一個 16 位元的二進位檢查碼。
CRC16 演算法是一種循環冗餘檢查（Cyclic Redundancy Check，CRC）的一種，
它通過除法運算得出校驗碼，
是一種效率高、可靠性強的錯誤檢查演算法。

CRC16 演算法的運作原理是通過對輸入資料進行除法運算，
得到 CRC16 檢查碼。
具體地，
CRC16 演算法將輸入資料看作一個二進位位元組序列，
通過將資料依次除以一個特定的多項式，
得到最終的 CRC16 檢查碼。

CRC16 演算法的實現有多種不同的方式，
其中最常用的是基於表格查找的方法。
此方法先預先計算出一個 CRC16 表格，
當需要計算一個新的 CRC16 檢查碼時，
通過查表的方式進行計算，
從而達到高效的計算速度。

總的來說，CRC16 演算法是一種可靠性高、
效率高的檢查碼演算法，
廣泛應用於資料通訊、
數據儲存等領域中，
能夠有效地檢測資料在傳輸或儲存過程中是否發生了錯誤。
CRC16是一種CRC校驗的演算法，
其使用的多項式為x^16 + x^15 + x^2 + 1，
稱為CRC-16-CCITT，
它將一個長度為n的資料块，
生成一個16位的校驗和。
具體實現過程如下：

1.將CRC初值設置為0xFFFF。
2.將資料逐位進行移位運算，將每個位上的值依次加入CRC計算中，
  每次運算結束後，
  CRC值再進行一次移位操作。
3.當所有資料的位都進行過上述運算後，
  最後得到的CRC值就是校驗和。
需要注意的是，
接收端也需要使用同樣的CRC演算法對資料進行校驗，
如果接收到的CRC值不等於計算出的CRC值，
就說明資料在傳輸過程中出現了錯誤。
在實際應用中，
CRC校驗常用於串口通訊、
網絡通訊等場合，
可以有效地檢測傳輸過程中出現的錯誤，
從而保障資料的完整性。

 */
    static const unsigned int wCRCTable[] = {
       0X0000, 0XC0C1, 0XC181, 0X0140, 0XC301, 0X03C0, 0X0280, 0XC241,
       0XC601, 0X06C0, 0X0780, 0XC741, 0X0500, 0XC5C1, 0XC481, 0X0440,
       0XCC01, 0X0CC0, 0X0D80, 0XCD41, 0X0F00, 0XCFC1, 0XCE81, 0X0E40,
       0X0A00, 0XCAC1, 0XCB81, 0X0B40, 0XC901, 0X09C0, 0X0880, 0XC841,
       0XD801, 0X18C0, 0X1980, 0XD941, 0X1B00, 0XDBC1, 0XDA81, 0X1A40,
       0X1E00, 0XDEC1, 0XDF81, 0X1F40, 0XDD01, 0X1DC0, 0X1C80, 0XDC41,
       0X1400, 0XD4C1, 0XD581, 0X1540, 0XD701, 0X17C0, 0X1680, 0XD641,
       0XD201, 0X12C0, 0X1380, 0XD341, 0X1100, 0XD1C1, 0XD081, 0X1040,
       0XF001, 0X30C0, 0X3180, 0XF141, 0X3300, 0XF3C1, 0XF281, 0X3240,
       0X3600, 0XF6C1, 0XF781, 0X3740, 0XF501, 0X35C0, 0X3480, 0XF441,
       0X3C00, 0XFCC1, 0XFD81, 0X3D40, 0XFF01, 0X3FC0, 0X3E80, 0XFE41,
       0XFA01, 0X3AC0, 0X3B80, 0XFB41, 0X3900, 0XF9C1, 0XF881, 0X3840,
       0X2800, 0XE8C1, 0XE981, 0X2940, 0XEB01, 0X2BC0, 0X2A80, 0XEA41,
       0XEE01, 0X2EC0, 0X2F80, 0XEF41, 0X2D00, 0XEDC1, 0XEC81, 0X2C40,
       0XE401, 0X24C0, 0X2580, 0XE541, 0X2700, 0XE7C1, 0XE681, 0X2640,
       0X2200, 0XE2C1, 0XE381, 0X2340, 0XE101, 0X21C0, 0X2080, 0XE041,
       0XA001, 0X60C0, 0X6180, 0XA141, 0X6300, 0XA3C1, 0XA281, 0X6240,
       0X6600, 0XA6C1, 0XA781, 0X6740, 0XA501, 0X65C0, 0X6480, 0XA441,
       0X6C00, 0XACC1, 0XAD81, 0X6D40, 0XAF01, 0X6FC0, 0X6E80, 0XAE41,
       0XAA01, 0X6AC0, 0X6B80, 0XAB41, 0X6900, 0XA9C1, 0XA881, 0X6840,
       0X7800, 0XB8C1, 0XB981, 0X7940, 0XBB01, 0X7BC0, 0X7A80, 0XBA41,
       0XBE01, 0X7EC0, 0X7F80, 0XBF41, 0X7D00, 0XBDC1, 0XBC81, 0X7C40,
       0XB401, 0X74C0, 0X7580, 0XB541, 0X7700, 0XB7C1, 0XB681, 0X7640,
       0X7200, 0XB2C1, 0XB381, 0X7340, 0XB101, 0X71C0, 0X7080, 0XB041,
       0X5000, 0X90C1, 0X9181, 0X5140, 0X9301, 0X53C0, 0X5280, 0X9241,
       0X9601, 0X56C0, 0X5780, 0X9741, 0X5500, 0X95C1, 0X9481, 0X5440,
       0X9C01, 0X5CC0, 0X5D80, 0X9D41, 0X5F00, 0X9FC1, 0X9E81, 0X5E40,
       0X5A00, 0X9AC1, 0X9B81, 0X5B40, 0X9901, 0X59C0, 0X5880, 0X9841,
       0X8801, 0X48C0, 0X4980, 0X8941, 0X4B00, 0X8BC1, 0X8A81, 0X4A40,
       0X4E00, 0X8EC1, 0X8F81, 0X4F40, 0X8D01, 0X4DC0, 0X4C80, 0X8C41,
       0X4400, 0X84C1, 0X8581, 0X4540, 0X8701, 0X47C0, 0X4680, 0X8641,
       0X8201, 0X42C0, 0X4380, 0X8341, 0X4100, 0X81C1, 0X8081, 0X4040 };
//CRC16計算用對應資料表
unsigned int  ModbusCRC16 (byte *nData, int wLength)
{
// 計算Modbus RTU通訊協議中的CRC16校驗和

// 輸入參數：
// nData：要進行CRC16校驗的數據
// wLength：數據的字節長度

// 返回值：
// unsigned int：計算得到的CRC16校驗和

    byte nTemp;
    unsigned int wCRCWord = 0xFFFF;    // 初始CRC16校驗和值

    while (wLength--)   // 對每個字節進行計算
    {
        nTemp = *nData++ ^ wCRCWord;    // 將當前字節與CRC16校驗和值進行異或運算
        wCRCWord >>= 8;   // 將CRC16校驗和值向右移8位
        wCRCWord  ^= wCRCTable[nTemp];    // 從查找表中查找對應的值，並將其與CRC16校驗和值進行異或運算
    }
    return wCRCWord;    // 返回計算得到的CRC16校驗和
} // End: CRC16


boolean CompareCRC16(unsigned int stdvalue, uint8_t Hi, uint8_t Lo)
{
  /*
       CompareCRC16: 比較接收到的 CRC16 校驗碼是否與標準值相同
    參數:
    stdvalue: 標準值 (unsigned int)
    Hi: 接收到的 CRC16 校驗碼高位 (uint8_t)
    Lo: 接收到的 CRC16 校驗碼低位 (uint8_t)
    回傳:
    true: 接收到的 CRC16 校驗碼與標準值相同
    false: 接收到的 CRC16 校驗碼與標準值不同
   */
           
      if (stdvalue == Hi*256+Lo)
        {
            return true ;
        }
        else
         {
            return false ;
        }
} 
